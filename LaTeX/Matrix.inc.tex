% -*- TeX:UK -*-
\chapter{Matrix calculations}
\begin{refsection}


\abstract{Matrices are vectors that have vectors as members. They are used to assign a vector of measured values (columns) to a vector of test subjects (rows). Thus, matrices are used as data structures in multivariate statistics.}

The routines in this unit are based on \parencite{Pre-89,Atk-83,Bor-86,Eng-87,Sed-83,Ste-73,Ren-02}. For the implementation of two-dimensional arrays we use the same method as for vectors. We could use an \texttt{array[1..MaxN, 1..MaxP]}, however, it is more memory efficient to use a ``flat'', one-dimensional array. The conversion of a two-dimensional position \skalar{i, j} into a one-dimensional is done in \texttt{SetVectorElement} and \texttt{GetVectorElement}.

\begin{lstlisting}[caption=]
  type MatrixStruc = record
                       Columns, Rows: word;
                       Data: array[1..MaxVector] of float;
                     end
      MatrixTyp    = ^MatrixStruc;
\end{lstlisting}

The method of error handling is the same too, except that we use the typed constant \texttt{MatrixError} as error flag. Therefore, the interface is

\begin{lstlisting}[caption=Interface of unit Matrix]
  unit Matrix;

  INTERFACE

  USES Math, MathFunc, Vector;

  CONST
    MatrixError: BOOLEAN = FALSE;   { toggle for error condition }

  TYPE
    MatrixStruc = RECORD
      Columns, Rows: WORD;
      Data: ARRAY[1..MaxVector] OF float;
    END;
    MatrixTyp = ^MatrixStruc;

  FUNCTION WriteErrorMessage(TEXT: STRING): CHAR;

  PROCEDURE CreateMatrix(VAR Mat: MatrixTyp; Rows, Columns: WORD; Value: float);

  PROCEDURE DestroyMatrix(VAR Mat: MatrixTyp);

  PROCEDURE ReadMatrix(MedStr: STRING; VAR A: MatrixTyp);

  PROCEDURE WriteMatrix(MedStr: STRING; CONST A: MatrixTyp; ValidFigures: BYTE);

  FUNCTION GetMatrixElement(CONST A: MatrixTyp; Row, Column: WORD): float;

  PROCEDURE SetMatrixElement(VAR A: MatrixTyp; Row, Column: WORD; Value: float);

  PROCEDURE CreateIdentityMatrix(VAR A: MatrixTyp; n: WORD);

  PROCEDURE CreateNullMatrix(VAR A: MatrixTyp; n: WORD);

  PROCEDURE CreateHilbertMatrix(VAR H: MatrixTyp; n: WORD);

  FUNCTION MatrixRows(CONST A: MatrixTyp): WORD;

  FUNCTION MatrixColumns(CONST A: MatrixTyp): WORD;

  { ************************************************************************* }

  PROCEDURE GetRow(CONST A: MatrixTyp; Z: WORD; VAR Vek: VectorTyp);

  PROCEDURE GetColumn(CONST A: MatrixTyp; S: WORD; VAR Vek: VectorTyp);

  PROCEDURE ExchangeColumns(VAR A: MatrixTyp; Column1, Column2: WORD);

  PROCEDURE ExchangeRows(VAR A: MatrixTyp; Row1, Row2: WORD);

  PROCEDURE SetRow(VAR A: MatrixTyp; CONST Vek: VectorTyp; Z: WORD);

  PROCEDURE SetColumn(VAR A: MatrixTyp; CONST Vek: VectorTyp; S: WORD);

  PROCEDURE CopyMatrix(CONST Source: MatrixTyp; VAR Dest: MatrixTyp);

  { *************************** Matrixalgebra ******************************* }

  PROCEDURE MatrixAdd(CONST A, B: MatrixTyp; VAR Res: MatrixTyp);

  PROCEDURE SkalarMultiplikation(VAR A: MatrixTyp; x: float);

  PROCEDURE MatrixInnerProduct(CONST A, B: MatrixTyp; VAR C: MatrixTyp);

  PROCEDURE HadamardSchurProduct(CONST A, B: MatrixTyp; VAR C: MatrixTyp);

  PROCEDURE MatrixDivision(CONST A, B: MatrixTyp; VAR C: MatrixTyp);

  PROCEDURE CenterData(VAR A: MatrixTyp);

  PROCEDURE ChangeMatrixNorm(VAR A: MatrixTyp; Norm: float);

  FUNCTION Determinante(CONST A: MatrixTyp): float;

  FUNCTION MatrixTrace(CONST A: MatrixTyp): float;

  FUNCTION FrobeniusNorm(CONST A: MatrixTyp): float;

  FUNCTION FrobeniusSkalarProduct(CONST A, B: MatrixTyp): float;

  PROCEDURE ERoMultAdd(VAR A: MatrixTyp; Faktor: float; Row1, Row2: WORD);

  PROCEDURE InverseMatrix(VAR A: MatrixTyp);

  PROCEDURE MatrixTranspose(CONST A: MatrixTyp; VAR B: MatrixTyp);

  PROCEDURE AntiSym(CONST A: MatrixTyp; VAR Symmetric, Antisymmetric: MatrixTyp);

  PROCEDURE Diag(VAR Matrix: MatrixTyp);

  PROCEDURE LeadingPrincipleMinors(VAR A: MatrixTyp; VAR V: VectorTyp);

  PROCEDURE NegativeMatrix(VAR A: MatrixTyp);

  { ****************************** spezielle Matrizen *********************** }

  FUNCTION MatrixSquare(CONST A: MatrixTyp): BOOLEAN;

  FUNCTION MatrixSymmetric(VAR A: MatrixTyp): BOOLEAN;

  FUNCTION MatrixLeftTrapezoid(VAR A: MatrixTyp): BOOLEAN;

  FUNCTION MatrixRightTrapezoid(VAR A: MatrixTyp): BOOLEAN;

  FUNCTION MatrixDiagonal(VAR A: MatrixTyp): BOOLEAN;

  FUNCTION MatrixUpperTriangular(VAR A: MatrixTyp): BOOLEAN;

  FUNCTION MatrixLowerTriangular(VAR A: MatrixTyp): BOOLEAN;

  FUNCTION MatrixUpperHessenberg(VAR A: MatrixTyp): BOOLEAN;

  FUNCTION MatrixLowerHessenberg(VAR A: MatrixTyp): BOOLEAN;

  FUNCTION MatrixTridiagonal(VAR A: MatrixTyp): BOOLEAN;

  FUNCTION MatrixPositivDefinite(CONST A: MatrixTyp): BOOLEAN;

  FUNCTION NullMatrix(VAR A: MatrixTyp): BOOLEAN;

  { ***************************** Vector/Matrix ***************************** }

  PROCEDURE DyadicVectorProduct(CONST A, B: VectorTyp; VAR C: MatrixTyp);

  PROCEDURE MultMatrixVector(CONST Mat: MatrixTyp; CONST Vek: VectorTyp;
    VAR Result: VectorTyp);

  PROCEDURE CangeVectorToMatrix(CONST Vek: VectorTyp; VAR Mat: MatrixTyp);

  { ************************* sorting ********************************** }

  PROCEDURE ShellSortMatrix(VAR t: MatrixTyp; Column: WORD);
  { sorts the rows of a matrix by column "Column" }


  IMPLEMENTATION

  VAR
    CH: CHAR;
\end{lstlisting}

\section{Generation and destruction of matrices}


\begin{lstlisting}[caption=Create a new matrix]
  PROCEDURE CreateMatrix(VAR Mat: MatrixTyp; Rows, Columns: WORD; Value: float);

  VAR
    i: WORD;
    x: longword;

  BEGIN
    x := Rows * Columns * SizeOf(float) + 2 * SizeOf(WORD) + 4;
    TRY
      GetMem(Mat, x);
    except
      CH := WriteErrorMessage(' Not enough memory to create matrix');
      MatrixError := true;
      EXIT;
    END;
    Mat^.Columns := Columns;
    Mat^.Rows := Rows;
    FOR i := 1 TO (Rows * Columns) DO
      Mat^.Data[i] := Value;
  END;
\end{lstlisting}


\begin{lstlisting}[caption=Remove a matrix and free its memory]
  PROCEDURE DestroyMatrix(VAR Mat: MatrixTyp);

  VAR
    x: longword;

  BEGIN
    x := MatrixRows(Mat) * MatrixColumns(Mat) * SizeOf(float) + 2 * SizeOf(WORD) + 4;
    FreeMem(Mat, x);
  END;
\end{lstlisting}

Matrices can be read from, and written to, files. The file name is in \texttt{MedStr}. Note that \texttt{'CON'} and \texttt{'PRN'} write to the console or the printer, respectively.

\begin{lstlisting}[caption=Read a matrix from file]
  PROCEDURE ReadMatrix(MedStr: STRING; VAR A: MatrixTyp);

  VAR
    i, j, n, p: WORD;
    x: float;
    Medium: TEXT;

  BEGIN
    Assign(Medium, MedStr);
    Reset(Medium);
    IF IOResult <> 0
      THEN
        BEGIN
          CH := WriteErrorMessage(' Reading a matrix: File not found');
          MatrixError := true;
          EXIT;
        END;
    ReadLn(Medium, n);
    ReadLn(Medium, p);
    IF ((n * p > MaxVector))
      THEN
        BEGIN
          CH := WriteErrorMessage(' Reading a matrix: Matrix too big');
          EXIT;
        END;
    CreateMatrix(A, n, p, 0.0);
    FOR i := 1 TO n DO
      BEGIN
        IF EoF(Medium)
          THEN
            BEGIN
              CH := WriteErrorMessage(' Reading a matrix: Unknown file format');
              MatrixError := true;
              EXIT;
            END;
        FOR j := 1 TO p DO
          BEGIN
            IF EoLn(Medium)
              THEN
                BEGIN
                  CH := WriteErrorMessage(' Reading a matrix: Unknown file format');
                  MatrixError := true;
                  EXIT;
                END;
            Read(Medium, x);
            IF IOResult <> 0
              THEN
                BEGIN
                  CH := WriteErrorMessage(' Reading a matrix: Unknown file format');
                  MatrixError := true;
                  EXIT;
                END;
            SetMatrixElement(A, i, j, x);
          END; { for j }
        ReadLn(Medium);
      END;  { for i }
    Close(Medium);
  END;
\end{lstlisting}


\begin{lstlisting}[caption=Write a matrix to a file]
  PROCEDURE WriteMatrix(MedStr: STRING; CONST A: MatrixTyp; ValidFigures: BYTE);

  VAR
    i, j: WORD;
    Medium: TEXT;

  BEGIN
    Assign(Medium, MedStr);
    Rewrite(Medium);
    Writeln(Medium, A^.Rows);
    Writeln(Medium, A^.Columns);
    IF NOT (IOResult = 0)
      THEN
        BEGIN
          CH := WriteErrorMessage(' Writing a matrix: Illegal File operation');
          MatrixError := true;
          EXIT;
        END;
    FOR i := 1 TO MatrixRows(A) DO
      BEGIN
        FOR j := 1 TO MatrixColumns(A) DO
          Write(Medium, FloatStr(GetMatrixElement(A, i, j), ValidFigures), ' ');
        Writeln(Medium);
      END;
    Close(Medium);
  END;
\end{lstlisting}

\section{Accesing and changing data in a matrix}

\begin{lstlisting}[caption=]
  FUNCTION MatrixRows(CONST A: MatrixTyp): WORD;

  BEGIN
    MatrixRows := A^.Rows;
  END;


  FUNCTION MatrixColumns(CONST A: MatrixTyp): WORD;

  BEGIN
    MatrixColumns := A^.Columns;
  END;


  FUNCTION GetMatrixElement(CONST A: MatrixTyp; Row, Column: WORD): float;

  VAR
    n, p: WORD;

  BEGIN
    n := MatrixRows(A);
    p := MatrixColumns(A);
    IF (Row <= n) AND (Column <= p)
      THEN
        GetMatrixElement := A^.Data[Pred(Row) * p + Column]
      ELSE
        BEGIN
          MatrixError := true;
          CH := WriteErrorMessage(' Attempt to read a non-existent matrix element');
        END;
  END;


  PROCEDURE SetMatrixElement(VAR A: MatrixTyp; Row, Column: WORD; Value: float);

  VAR
    n, p: WORD;

  BEGIN
    n := MatrixRows(A);
    p := MatrixColumns(A);
    IF (Row <= n) AND (Column <= p)
      THEN
        A^.Data[Pred(Row) * p + Column] := Value
      ELSE
        BEGIN
          MatrixError := true;
          CH := WriteErrorMessage(' Attempt to write to a non-existent matrix element');
        END;
  END;
\end{lstlisting}

Just as with vectors, we cannot simply use \arr{A} = \arr{B} to copy a matrix. Copying should be done with the following routine.

\begin{lstlisting}[caption=copy a matrix]
  PROCEDURE CopyMatrix(CONST Source: MatrixTyp; VAR Dest: MatrixTyp);

  VAR
    i, j, p, n: WORD;

  BEGIN
    n := MatrixRows(Source);
    p := MatrixColumns(Source);
    CreateMatrix(Dest, n, p, 0.0);
    IF MatrixError THEN EXIT;
    FOR i := 1 TO n DO
      FOR j := 1 TO p DO
        SetMatrixElement(Dest, i, j, GetMatrixElement(Source, i, j));
  END;
\end{lstlisting}


\begin{lstlisting}[caption=Row operations]
  PROCEDURE GetRow(CONST A: MatrixTyp; Z: WORD; VAR Vek: VectorTyp);

  VAR
    j, m, n: WORD;

  BEGIN
    m := MatrixRows(A);
    n := MatrixColumns(A);
    IF Z > m
      THEN
        BEGIN
          CH := WriteErrorMessage(' Matrix-Error: accessing a non-existent row');
          MatrixError := TRUE;
          EXIT;
        END;
    CreateVector(Vek, n, 0.0);
    FOR j := 1 TO n DO
      SetVectorElement(Vek, j, GetMatrixElement(A, z, j));
  END;

  PROCEDURE SetRow(VAR A: MatrixTyp; CONST Vek: VectorTyp; Z: WORD);

  VAR
    j, n, p: WORD;

  BEGIN
    n := MatrixRows(A);
    p := MatrixColumns(A);
    IF (Z > n) OR (p <> VectorLength(Vek))
      THEN
        BEGIN
          CH := WriteErrorMessage('Matrix-error: set row with illegal parameter');
          MatrixError := TRUE;
          EXIT;
        END;
    FOR j := 1 TO p DO
      SetMatrixElement(A, z, j, GetVectorElement(Vek, j));
  END;


  PROCEDURE ExchangeRows(VAR A: MatrixTyp; Row1, Row2: WORD);

  VAR
    Dummy: float;
    j, n, p: WORD;

  BEGIN
    n := MatrixRows(A);
    p := MatrixColumns(A);
    IF ((Row1 > n) OR (Row2 > n))
      THEN
        BEGIN
          CH := WriteErrorMessage('Matrix-error: accessing non-existant row');
          MatrixError := TRUE;
          EXIT;
        END;
    FOR j := 1 TO p DO
      BEGIN
        Dummy := GetMatrixElement(A, Row1, j);
        SetMatrixElement(A, Row1, j, GetMatrixElement(A, Row2, j));
        SetMatrixElement(A, Row2, j, Dummy);
      END;
  END; { procedure ExchangeRows }
\end{lstlisting}


\begin{lstlisting}[caption=Column operations]
  PROCEDURE GetColumn(CONST A: MatrixTyp; S: WORD; VAR Vek: VectorTyp);

  VAR
    i, n, p: WORD;

  BEGIN
    n := MatrixRows(A);
    p := MatrixColumns(A);
    IF (S > p)
      THEN
        BEGIN
          CH := WriteErrorMessage(' Matrix-error: accessing non-existant column');
          MatrixError := TRUE;
          EXIT;
        END;
    CreateVector(Vek, n, 0.0);
    FOR i := 1 TO n DO
      SetVectorElement(Vek, i, GetMatrixElement(A, i, S));
  END;


  PROCEDURE SetColumn(VAR A: MatrixTyp; CONST Vek: VectorTyp; S: WORD);

  VAR
    i, n, p: WORD;

  BEGIN
    n := MatrixRows(A);
    p := MatrixColumns(A);
    IF (S > p) OR (n <> VectorLength(Vek))
      THEN
        BEGIN
          CH := WriteErrorMessage(' Matrix-error: setting non-existant column');
          MatrixError := TRUE;
          EXIT;
        END;
    FOR i := 1 TO n DO
      SetMatrixElement(A, i, S, GetVectorElement(Vek, i));
  END;


  PROCEDURE ExchangeColumns(VAR A: MatrixTyp; Column1, Column2: WORD);
  { Columns n und m vertauschen }

  VAR
    i, n, p: WORD;
    Dummy: float;

  BEGIN
    n := MatrixRows(A);
    p := MatrixColumns(A);
    IF ((Column1 > p) OR (Column2 > p))
      THEN
        BEGIN
          CH := WriteErrorMessage(' Matrix-errorr: accessing non-existant column');
          MatrixError := TRUE;
          EXIT;
        END;
    FOR i := 1 TO n DO
      BEGIN
        Dummy := GetMatrixElement(A, i, Column1);
        SetMatrixElement(A, i, Column1, GetMatrixElement(A, i, Column2));
        SetMatrixElement(A, i, Column2, Dummy);
      END;
  END;
\end{lstlisting}

The following routine inverts the sign of all elements of a matrix:

\begin{lstlisting}[caption=invert sign of all matrix elements]
  PROCEDURE NegativeMatrix(VAR A: MatrixTyp);

  VAR
    i, j: WORD;

  BEGIN
    FOR i := 1 TO MatrixRows(A) DO
      FOR j := 1 TO MatrixColumns(A) DO
        SetMatrixElement(A, i, j, -GetMatrixElement(A, i, j));
  END;
\end{lstlisting}


\section{Special matrix types}

Some matrices have special properties that simplify calculations with them or allow a particular method to be used.

\subsection{Identity matrix}

In an identity matrix all diagonal elements are unity, all off-diagonal elements zero. It is the neutral element of matrix multiplication.

\begin{lstlisting}[caption=identity matrix]
  PROCEDURE CreateIdentityMatrix(VAR A: MatrixTyp; n: WORD);
  { n*n identity matrix }

  VAR
    i: WORD;

  BEGIN
    CreateMatrix(A, n, n, 0.0);
    IF MatrixError THEN EXIT;
    FOR i := 1 TO n DO
      SetMatrixElement(A, i, i, 1.0);
  END;
\end{lstlisting}

\subsection{The null-matrix}

A matrix \arr{A} is called null-matrix if all its elements are the neutral element of addition, zero. 

\begin{lstlisting}[caption=null matrix]
  PROCEDURE CreateNullMatrix(VAR A: MatrixTyp; n: WORD);

  BEGIN
    CreateMatrix(A, n, n, 0.0);
  END;
\end{lstlisting}

The following function tests, if a matrix is a null-matrix. Again, we set all elements to zero precisely, that are absolute smaller than the constant \texttt{Zero}.

\begin{lstlisting}[caption=are all matrix matrix elements zero?]
  FUNCTION NullMatrix(VAR A: MatrixTyp): BOOLEAN;

  VAR
    i, j: WORD;

  BEGIN
    Result := TRUE;
    FOR i := 1 TO MatrixRows(A) DO
      FOR j := 1 TO MatrixColumns(A) DO
        IF Abs(GetMatrixElement(A, i, j)) > Zero
          THEN
            BEGIN
              Result := FALSE;
              EXIT;
            END
          ELSE
            SetMatrixElement(A, i, j, 0.0);
  END;
\end{lstlisting}

\subsection{The \Name{Hilbert}-matrix}

The \Name{Hilbert}-matrix \(\arr{H}_{n\times n} \) with \(\AbsVec{h}_{ij} = \frac{1}{i+j-1} \) is often used as a test system for matrix inversion and solving linear equations, as it is quite ill-conditioned.

\begin{lstlisting}[caption=Hilbert matrix]
  PROCEDURE CreateHilbertMatrix(VAR H: MatrixTyp; n: WORD);

  VAR
    i, j: WORD;

  BEGIN
    CreateMatrix(H, n, n, 0.0);
    FOR i := 1 TO n DO
      FOR j := 1 TO n DO
        SetMatrixElement(H, i, j, 1 / Pred(i + j));
  END;
\end{lstlisting}

\subsection{The quadratic matrix}


A matrix is quadratic if it has the same number of lines and columns:

\begin{lstlisting}[caption=is matrix square?]
  FUNCTION MatrixSquare(CONST A: MatrixTyp): BOOLEAN;

  BEGIN
    Result := MatrixRows(A) = MatrixColumns(A);
  END;
\end{lstlisting}

\subsection{The symmetric matrix}

A Matrix is symmetric if it is quadratic and \(\AbsVec{x}_{ij} = \AbsVec{x}_{ji} \enspace\forall\enspace i,j \in 1\ldots n \). Since we cannot test for identity of real numbers, we test for the difference being smaller than the typed constant \texttt{Zero}. In that case, we set the upper diagonal to the lower, to avoid numeric difficulties in later calculations.

\begin{lstlisting}[caption=]
  FUNCTION MatrixSymmetric(VAR A: MatrixTyp): BOOLEAN;

  VAR
    i, j, Dimen: WORD;
    x, y: float;

  BEGIN
    Dimen := MatrixRows(A);
    IF NOT (MatrixSquare(A))
      THEN
        BEGIN
          MatrixSymmetric := FALSE;
          EXIT;
        END;
    FOR i := 1 TO Dimen DO
      FOR j := 1 TO Dimen DO
        BEGIN
          x := GetMatrixElement(A, i, j);
          y := GetMatrixElement(A, j, i);
          IF Abs(x - y) > Zero
            THEN
              BEGIN
                MatrixSymmetric := FALSE;
                EXIT;
              END
            ELSE   // make sure they are identical
              SetMatrixElement(A, i, j, GetMatrixElement(A, j, i));
        END;
    MatrixSymmetric := TRUE;
  END;
\end{lstlisting}

\subsection{Trapezoid matrices}

A matrix is left trapezoid, if all elements below the diagonal are zero. A matrix is right trapezoid if all elements above the diagonal are zero. Again, if these elements are smaller than \texttt{Zero}, we set them to 0.0:


 \begin{lstlisting}[caption=is matrix left trapezoid]
  FUNCTION MatrixLeftTrapezoid(VAR A: MatrixTyp): BOOLEAN;

  VAR
    i, j: WORD;

  BEGIN
    Result := FALSE;
    FOR i := 1 TO MatrixRows(A) DO
      FOR j := 1 TO Pred(i) DO
        IF Abs(GetMatrixElement(A, i, j)) > Zero
          THEN EXIT
          ELSE SetMatrixElement(A, i, j, 0.0);
    Result := TRUE;
  END;


  FUNCTION MatrixRightTrapezoid(VAR A: MatrixTyp): BOOLEAN;

  VAR
    i, j: WORD;

  BEGIN
    Result := FALSE;
    FOR i := 1 TO MatrixRows(A) DO
      FOR j := Succ(i) TO MatrixColumns(A) DO
        IF Abs(GetMatrixElement(A, i, j)) > Zero
          THEN EXIT
          ELSE SetMatrixElement(A, i, j, 0.0); // make sure
    Result := TRUE;
  END;
\end{lstlisting}

\subsection{The diagonal matrix and function diag}

If only the diagonal elements are different from zero, we call a matrix diagonal:

\begin{lstlisting}[caption=is matrix  diagonal]
  FUNCTION MatrixDiagonal(VAR A: MatrixTyp): BOOLEAN;

  BEGIN
    Result := MatrixRightTrapezoid(A) AND MatrixLeftTrapezoid(A);
  END;
\end{lstlisting}

The procedure \texttt{Diag} sets all of-diagonal elements of a matrix to zero:

\begin{lstlisting}[caption=set all of-diagonal elements to zero]
  PROCEDURE Diag(VAR Matrix: MatrixTyp);

  VAR
    n, p, i, j: WORD;

  BEGIN
    n := MatrixRows(Matrix);
    p := MatrixColumns(Matrix);
    IF (p <> n)
      THEN
        BEGIN
          CH := WriteErrorMessage('Matrix-error: Diag of a non-square matrix');
          MatrixError := TRUE;
          EXIT;
        END;
    FOR i := 1 TO n DO
      FOR j := Succ(i) TO p DO
        BEGIN
          SetMatrixElement(Matrix, i, j, 0.0);
          SetMatrixElement(Matrix, j, i, 0.0);
        END;
  END;
\end{lstlisting}

\subsection{Triangular matrices}

Square matrices which are trapezoid are called triangular:

\begin{lstlisting}[caption=is matrix triangular?]
  FUNCTION MatrixUpperTriangular(VAR A: MatrixTyp): BOOLEAN;

  BEGIN
    Result := MatrixLeftTrapezoid(A) AND MatrixSquare(A);
  END;


  FUNCTION MatrixLowerTriangular(VAR A: MatrixTyp): BOOLEAN;

  BEGIN
    Result := MatrixRightTrapezoid(A) AND MatrixSquare(A);
  END;
\end{lstlisting}

\subsection{\Name{Hessenberg} matrices}

The elements \(\AbsVec{a}_{ij}, j = i+1 \) are called superdiagonal. A matrix has the upper \Name{Hessenberg} form if it is quadratic and all elements above the superdiagonal are zero. The elements \(\AbsVec{a}_{ij}, j = i-1 \) are called infradiagonal. A matrix has the lower \Name{Hessenberg} form if it is quadratic and all elements below the infradiagonal are zero. If a matrix has both upper and lower \Name{Hessenberg} form, it is called tridiagonal.


\begin{lstlisting}[caption=has matrix the upper Hessenberg form?]
  FUNCTION MatrixUpperHessenberg(VAR A: MatrixTyp): BOOLEAN;

  VAR
    i, j: WORD;

  BEGIN
    Result := FALSE;
    IF NOT (MatrixSquare(A)) THEN EXIT;
    FOR i := 1 TO MatrixRows(A) DO
      FOR j := 1 TO i - 2 DO
        IF Abs(GetMatrixElement(A, i, j)) > Null
          THEN EXIT
          ELSE SetMatrixElement(A, i, j, 0.0);
    Result := TRUE;
  END;


  FUNCTION MatrixLowerHessenberg(VAR A: MatrixTyp): BOOLEAN;

  VAR
    i, j: WORD;

  BEGIN
    Result := FALSE;
    IF NOT (MatrixSquare(A)) THEN EXIT;
    FOR i := 1 TO MatrixRows(A) DO
      FOR j := i + 2 TO MatrixColumns(A) DO
        IF Abs(GetMatrixElement(A, i, j)) > Null
          THEN EXIT
          ELSE SetMatrixElement(A, i, j, 0.0);
    Result := TRUE;
  END;


  FUNCTION MatrixTridiagonal(VAR A: MatrixTyp): BOOLEAN;

  BEGIN
    Result := MatrixUpperHessenberg(A) AND MatrixLowerHessenberg(A);
  END;
\end{lstlisting}

\subsection{Positive and negative definite matrices}

A square matrix is positive definite, if all diagonal elements are \(> 0 \), the largest element is on the diagonal and \(\AbsVec{a}_{ij}^2 < \AbsVec{a}_{ii} * \AbsVec{a}_{jj} \). For such matrices, the \Name{Gauss}-algorithm without pivot search can be used. Their eigenvalues are all \(> 0 \); positive semi-definite matrix have one or more eigenvalues that are \(= 0 \), their rank is equal to the number of eigenvalues \(> 0 \).

\begin{lstlisting}[caption=is matrix positive definite?]
  FUNCTION MatrixPositivDefinite(CONST A: MatrixTyp): BOOLEAN;

  VAR
    i, j: WORD;
    Akt, Max: float;

  BEGIN
    Result := FALSE;
    Max := 0.0;
    IF NOT (MatrixSquare(A)) THEN EXIT;
    FOR i := 1 TO MatrixRows(A) DO
      BEGIN
        Akt := GetMatrixElement(A, i, i);
        IF Akt <= 0 THEN EXIT;
        IF Akt > Max THEN Max := Akt;
      END;
    FOR i := 1 TO MatrixRows(A) DO
      BEGIN
        FOR j := 1 TO Pred(i) DO
          BEGIN
            Akt := GetMatrixElement(A, i, j);
            IF Akt > Max
              THEN EXIT;
            IF Sqr(Akt) >= GetMatrixElement(A, i, i) * GetMatrixElement(A, j, j)
              THEN EXIT;
          END;
        FOR j := Succ(i) TO MatrixColumns(A) DO
        BEGIN
          Akt := GetMatrixElement(A, i, j);
          IF Akt > Max
            THEN EXIT;
          IF Sqr(Akt) >= GetMatrixElement(A, i, i) * GetMatrixElement(A, j, j)
            THEN EXIT;
        END;
      END;
    Result := TRUE;
  END;
\end{lstlisting}


\section{Calculation with matrices}

\subsection{Matrix norms}

The trace of a quadratic matrix is the sum of its diagonal elements:

\begin{equation}
  \mathrm{tr}(\arr{A}_{n \times n}) = \sum_{i=1}^n{\AbsVec{a}_{ii}}
\end{equation}

The following rules apply:
\begin{eqnarray}
  \trace(\arr{A}+\arr{B}) &=& \trace(\arr{A}) + \trace(\arr{B}) \\
  \trace(\arr{AB}) &=& \trace(\arr{BA}) \\
  \trace(\arr{A}^T\arr{A}) &=& \trace(\arr{A}\arr{A}^T) = \sum_{i=1}^{n}{\sum_{j=1}^{p}{a_{ij}^2}}
\end{eqnarray}

\begin{lstlisting}[caption=Trace of a matrix]
  FUNCTION MatrixTrace(CONST A: MatrixTyp): float;

  VAR
    i, n, p: WORD;
    Sum: float;

  BEGIN
    n := MatrixRows(A);
    p := MatrixColumns(A);
    IF (n <> p)
      THEN
        BEGIN
          CH := WriteErrorMessage(' Matrix-error: trace of a matrix that is not square');
          MatrixError := TRUE;
          EXIT;
        END;
    Sum := 0;
    FOR i := 1 TO n DO
      Sum := Sum + GetMatrixElement(A, i, i);
    MatrixTrace := Sum;
  END;
\end{lstlisting}

Matrix-norms \textbf{induced by vector-norms} for a (not necessarily quadratic) matrix \(\arr{A}_{n \times p} \) are:
\begin{align}
   \|A\|_\infty &= \max_{1\leq i\leq n}\sum_{i=1}^p{|a_{ij}|} \\
   \|A\|_1 &= \max_{1\leq j\leq p}\sum_{i=1}^p{|a_{ij}|} \\
   \|A\|_F &= \sqrt{\sum_{i=1}^n{\sum_{j=1}^p{|\AbsVec{a}_{ij}|^2}}}
\end{align}
the maximum absolute row sum, maximum absolute column sum and \Name{Frobenius}-norm, respectively. For example

\begin{tabular}{|ccc|c}
  -3 &  5 &  7 & 15 \\
   2 &  6 &  4 & 12 \\
   0 &  2 &  8 & 10 \\
   \midrule
   5 & 13 & 19 &    \\
\end{tabular}

\( \|A\|_1 = \max(5, 13, 19) = 19 \) and \(\|A\|_\infty = \max(15, 12, 10) = 15 \). The trace \(\mathrm{tr}(\arr{A}) = -3 + 6 + 8 = 11 \). The \Name{Frobenius}-Norm is
\begin{equation}
  \|A\|_F = \sqrt{(-3^2+5^2+7^2) + (2^2+6^2+4^2) + (0^2+2^2+8^2)} = \sqrt{207} = 14.4
\end{equation}

\textbf{Entry-wise norms} treat a matrix \(\arr{A}_{n\times p} \) as vector of length \(np \). Then
\begin{equation}
  \|A\|_q = \sqrt[q]{\sum_{i=1}^{n\times p}{|\AbsVec{a}_{i}|^q}}
\end{equation}
with the special cases \(q=2 \) the \Name{Frobenius}-norm and \(q=\infty \) the maximum norm.

The \textbf{Schatten-norms} are defined as follows:
\begin{equation}
  \|\arr{A}\|_q = \sqrt[q]{\sum_{i=1}^{\min(n,p)}{\sigma_i^q}}
\end{equation}
with \(\sigma_i \) the i-th singular value (\Foreign{vide infra}) of \arr{A}.

\begin{lstlisting}[caption=]
  FUNCTION FrobeniusNorm(CONST A: MatrixTyp): float;

  VAR
    i, j, n, p: WORD;
    Sum: extended;

  BEGIN
    n := MatrixRows(A);
    p := MatrixColumns(A);
    Sum := 0.0;
    FOR i := 1 TO n DO
      FOR j := 1 TO p DO
        Sum := Sum + Sqr(GetMatrixElement(A, i, j));
    FrobeniusNorm := Sqrt(Sum);
  END;
\end{lstlisting}

The \Name{Frobenius} scalar product of two matrices \(\|\arr{A,B}\| = \mathrm{trace}(\arr{A}^T \arr{B}) \). It follows that \(\|\arr{A}\|_F = \sqrt{\|\arr{A}^T, \arr{A}\|} \):

\begin{lstlisting}[caption=Frobenius skalar product]
  FUNCTION FrobeniusSkalarProduct(CONST A, B: MatrixTyp): float;

  VAR
    CH: CHAR;
    C, D: MatrixTyp;
    n, p: WORD;

  BEGIN
    n := MatrixRows(A);
    p := MatrixColumns(A);
    IF NOT ((n = MatrixRows(B)) AND (p = MatrixColumns(B)))
      THEN
        BEGIN
          CH := WriteErrorMessage(
            ' Matrix-error: Frobenius-Skalar product of incompatible matrices');
          MatrixError := TRUE;
          EXIT;
        END;
    MatrixTranspose(A, C);          // C = A^T
    MatrixInnerProduct(C, B, D);    // D = A^T B
    FrobeniusSkalarProduct := MatrixTrace(D);
    DestroyMatrix(C);
    DestroyMatrix(D);
  END;
\end{lstlisting}

\subsection{Determinant}

To calculate the determinant, we will need a little helper function, that adds a multiple of row 1 to row 2. It is also required for the solution of systems of equations.

\begin{lstlisting}[caption=add multiple of row 1 to row 2]
  PROCEDURE ERoMultAdd(VAR A: MatrixTyp; Faktor: float; Row1, Row2: WORD);

  VAR
    j: WORD;

  BEGIN
    FOR j := 1 TO MatrixColumns(A) DO
      SetMatrixElement(A, Row2, j, GetmatrixElement(A, Row2, j) +
        GetMatrixElement(A, Row1, j) * Faktor);
  END;
\end{lstlisting}


The determinant of a square matrix \(|\arr{A}_{n \times n}| \) is defined as the sum of all \skalar{n}! possible products of \skalar{n} elements such that
\begin{enumerate}
  \item{each product contains one element from every row and every column}
  \item{the factors in each product are written so that the column subscripts appear in order of magnitude and each product is then preceded by a plus or minus sign according to whether the number of inversions in the row subscripts is even or odd.}
  \item{An inversion occurs whenever a larger number precedes a smaller one.}
\end{enumerate}
For a \(3\times 3 \) matrix, this is
\begin{gather}
   |\arr{A}| = \det\begin{pmatrix}
                      a_{11} & a_{12} & a_{13} \\
                      a_{21} & a_{22} & a_{23} \\
                      a_{31} & a_{32} & a_{33}
                   \end{pmatrix} \\
                   =   a_{11} a_{22} a_{33} + a_{12} a_{23} a_{31} + a_{13} a_{32} a_{21} - a_{31} a_{22} a_{13} - a_{32} a_{23} a_{11} - a_{33} a_{12} a_{21}
\end{gather}
For larger matrices, this becomes unwieldy.

The following special cases exist:
\begin{itemize}
  \item{For diagonal matrices, the determinant is the product of the diagonal elements \(|\arr{X}| = \prod_{i=1}^{n}(\AbsVec{x}_i) \). }
  \item{If a square matrix is singular, then its determinant is \( |\arr{X}| = 0 \), if it is non-singular, the determinant \( |\arr{X}| \neq\ 0 \).}
  \item{If a matrix is \textbf{positive definite}, then its determinant is positive.}
  \item{\( |\arr{X}^T| = |\arr{X}| \), \(|\arr{X}^{-1}| = |\arr{X}|^{-1} \)}
\end{itemize}

\begin{lstlisting}[caption=Determinant of a matrix]
  FUNCTION Determinante(CONST A: MatrixTyp): float;

  VAR
    PartialDeter, Multiplier: float;
    Row, ReferenceRow: WORD;
    DetEqualsMaxError: BOOLEAN;
    Copy: MatrixTyp;

    PROCEDURE Pivot(ReferenceRow: WORD; VAR PartialDeter: float;
    VAR DetEqualsMaxError: BOOLEAN);
       {- This procedure searches the ReferenceRow column of the matrix Data for
          the first non-MaxError element below the diagonal. If it finds one, then
          the procedure switches rows so that the non-MaxError element is on the
          diagonal. Switching rows changes the determinant by a factor of -1;
          this change is returned in PartialDeter. If it doesn't find one, the
          matrix is singular and the Determinant is MaxError (DetEqualsMaxError = true
          is returned.  -}

    VAR
      NewRow: INTEGER;

    BEGIN
      DetEqualsMaxError := TRUE;
      NewRow := ReferenceRow;
      WHILE DetEqualsMaxError AND (NewRow < MatrixRows(Copy)) DO
        BEGIN  { Try to find a row with a non-MaxError    }
          NewRow := Succ(NewRow);
          IF Abs(GetMatrixElement(Copy, NewRow, ReferenceRow)) > MaxError
            THEN
              BEGIN
                ExchangeRows(Copy, NewRow, ReferenceRow); { Switch these two rows }
                DetEqualsMaxError := FALSE;
                PartialDeter := -PartialDeter;  { Switching rows changes }
              END; { the determinant by a factor of -1 }
        END;
    END; { procedure Pivot }

  BEGIN  { Determinante }
    IF MatrixRows(A) = 1
      THEN
        BEGIN
          Result := GetMatrixElement(A, 1, 1);
          EXIT;
        END;
    CopyMatrix(A, Copy);
    IF MatrixError THEN EXIT;
    DetEqualsMaxError := FALSE;
    PartialDeter := 1;
    ReferenceRow := 0;
    { Make the matrix upper triangular }
    WHILE NOT (DetEqualsMaxError) AND (ReferenceRow < Pred(MatrixRows(Copy))) DO
      BEGIN
        INC(ReferenceRow);
        { If diagonal element is MaxError then switch rows }
        IF Abs(GetMatrixElement(Copy, ReferenceRow, ReferenceRow)) < MaxError
          THEN Pivot(ReferenceRow, PartialDeter, DetEqualsMaxError);
        IF NOT (DetEqualsMaxError)
          THEN
            FOR Row := Succ(ReferenceRow) TO MatrixRows(Copy) DO
            { Make the ReferenceRow element of this row MaxError }
              IF Abs(GetMatrixElement(Copy, Row, ReferenceRow)) > MaxError
                THEN
                  BEGIN
                    Multiplier :=
                      -GetMatrixElement(Copy, Row, ReferenceRow) /
                      GetMatrixElement(Copy, ReferenceRow, ReferenceRow);
                    EROmultAdd(Copy, Multiplier, ReferenceRow, Row);
                  END;
        { Multiply the diagonal Term into PartialDeter }
        PartialDeter := PartialDeter * GetMatrixElement(Copy, ReferenceRow, ReferenceRow);
      END; { while }
    IF DetEqualsMaxError
      THEN
        Result := 0
      ELSE
        Result := PartialDeter * GetMatrixElement(Copy, MatrixRows(Copy),
        MatrixColumns(Copy));
    DestroyMatrix(Copy);
  END; { function Determinante }
\end{lstlisting}

Example:
\begin{gather}
   \det
   \begin{pmatrix}
      1.00 & 2.00 & 0.00 & -1.00 \\
     -1.00 & 4.00 & 3.00 & -0.50 \\
      2.00 & 2.00 & 1.00 & -3.00 \\
      0.00 & 0.00 & 3.00 & -4.00
   \end{pmatrix} = 21.0
\end{gather}

\subsubsection{Leading principle minors}

The leading principle minors of a symmetric matrix \(\arr{A}_{n \times n} \) are the determinants of the sub-matrices with \(1, 2\ldots n \) rows and columns, starting with the upper left corner. \arr{A} is positive definite if all principal minors are positive, it is negative definite if all even principle minors are positive, all odd negative (\Name{Sylvester}-criterion).

\begin{lstlisting}[caption=Leading principle minors]
  PROCEDURE LeadingPrincipleMinors(VAR A: MatrixTyp; VAR V: VectorTyp);
  // Implementierung nicht elegant, bei gro√üen Matrizen Wiederholung vermeiden

  VAR
    n, i, j, k: WORD;
    B: MatrixTyp;

  BEGIN
    IF NOT MatrixSymmetric(A)
      THEN
        BEGIN
          CH := WriteErrorMessage( 'Matrix-error: leading principle minors of a non-square matrix');
          MatrixError := TRUE;
          EXIT;
        END;
    n := MatrixRows(A);
    CreateVector(V, n, 0.0);
    FOR i := 1 TO n DO
      BEGIN
        CreateMatrix(B, i, i, 0.0);
        FOR j := 1 TO i DO
          FOR k := 1 TO i DO
            SetMatrixElement(B, j, k, GetMatrixElement(A, j, k));
        SetVectorElement(V, i, Determinante(B));
        DestroyMatrix(B);
      END;
    FOR i := 1 TO n DO
      IF Abs(GetVectorElement(V, i)) < Zero THEN SetVectorElement(V, i, 0);
  END;
\end{lstlisting}

The following routine changes the norm of a matrix:

\begin{lstlisting}
  PROCEDURE ChangeMatrixNorm(VAR A: MatrixTyp; Norm: float);

  VAR
    SP: float;
    i, j: WORD;

  BEGIN
    IF Abs(Norm) < MaxError
      THEN
        BEGIN
          CH := WriteErrorMessage(' Norm of a matrix must be greater than 0');
          MatrixError := true;
          EXIT;
        END;
    SP := 0;
    FOR i := 1 TO MatrixRows(A) DO
      FOR j := 1 TO MatrixColumns(A) DO
        SP := SP + Sqr(GetMatrixElement(A, i, j));
    IF Abs(SP) < MaxError
      THEN
        BEGIN
          CH := WriteErrorMessage(' Norm of a matrix: no solution');
          MatrixError := true;
          EXIT;
        END;
    Norm := Norm / Sqrt(SP);
    FOR i := 1 TO MatrixRows(A) DO
      FOR j := 1 TO MatrixColumns(A) DO
        SetMatrixElement(A, i, j, GetMatrixElement(A, i, j) * norm);
  END;
\end{lstlisting}

\subsection{Matrix transpose}

The transpose of a matrix \(\arr{A}^T \) is generated by turning the matrix by \ang{90}, so that rows turn into columns and \Foreign{vice versa}. In the following routine, the input matrix and its transpose must be different:

\begin{lstlisting}[caption=]
  PROCEDURE MatrixTranspose(CONST A: MatrixTyp; VAR B: MatrixTyp);

  VAR
    i, j, n, p: WORD;

  BEGIN
    n := MatrixRows(A);
    p := MatrixColumns(A);
    CreateMatrix(B, p, n, 0.0);
    FOR i := 1 TO n DO
      FOR j := 1 TO p DO
        SetMatrixElement(B, j, i, GetMatrixElement(A, i, j));
  END;
\end{lstlisting}

For matrices with complex elements, the \textbf{conjugate (\Name{Hermite}ian) transpose} \( \arr{A}^* \) is obtained from the transpose by calculating the complex conjugate of each element. For real matrices, \( \arr{A}^* = \arr{A}^T \). Matrices, for which \( \arr{A}^* \arr{A} = \arr{A} \arr{A}^* \) are called \textbf{normal}.

\subsubsection{Orthogonal vectors and matrices}

Two vectors are said to be orthogonal (perpendicular) if they have the same size and \(\AbsVec{a}^T\AbsVec{b} = 0 \). If \(\sqrt{\AbsVec{a}^T \AbsVec{a}} \) is the length of a vector, then \(\AbsVec{c} = \frac{\AbsVec{a}}{\sqrt{\AbsVec{a}^T \AbsVec{a}}} \) is said to be normalised and \(\AbsVec{c}^T \AbsVec{c} = 1 \).

A matrix \(\arr{C} \) is orthogonal if all its columns \(\AbsVec{c}_1, \AbsVec{c}_2, \ldots, \AbsVec{c}_p \) are normalised and orthogonal to each other. Then \(\arr{C}^T\arr{C} = \arr{C}\arr{C}^T = \mathbf{I} \), thus the rows are also normalised and orthogonal.

If \(\AbsVec{z} = \arr{C}\AbsVec{x} \) and \(\arr{C} \) is orthogonal, then
\begin{equation}
  \AbsVec{z}^T\AbsVec{z} = (\arr{C}\AbsVec{x})^T (\arr{C}\AbsVec{x}) =
    \AbsVec{x}^T\arr{C}^T\arr{C}\AbsVec{x} = \AbsVec{x}^T\mathbf{I}\AbsVec{x} = \AbsVec{x}^T\AbsVec{x}
\end{equation}
and \(\AbsVec{x} \) and \(\AbsVec{z} \) have the same length, but the axes are rotated.

\subsection{Matrix inverse}
The inverse of a matrix \(\arr{A}^{-1} \) is defined as \(\arr{A} \arr{A}^{-1} = \arr{I} \) the identity matrix (diagonal matrix with all diagonal elements equal 1.0), it is equivalent to the reciprocal of a number:

\begin{lstlisting}[caption=Inverse of a matrix]
  PROCEDURE InverseMatrix(VAR A: MatrixTyp);

  VAR
    i, j, m, n, p: WORD;
    NoExch: 0..MaxVector;
    Exch: ARRAY [1..MaxVector, 1..2] OF INTEGER;


    PROCEDURE Transform(m: WORD);

    VAR
      B: MatrixTyp;
      i, j: WORD;
      Pivot: float;

    BEGIN
      CopyMatrix(A, B);
      Pivot := GetMatrixElement(B, m, m);
      IF Abs(Pivot) <= MaxError THEN
      BEGIN
        CH := WriteErrorMessage('Matrix error: inversion of singular matrix');
        MatrixError := true;
        EXIT;
      END;
      FOR i := 1 TO n DO
        FOR j := 1 TO n DO
          IF i <> m
            THEN
              IF j <> m
                THEN
                  SetMatrixElement(B, i, j, GetMatrixElement(A, i, j) -
                     GetMatrixElement(A, i, m) * GetMatrixElement(A, m, j) / Pivot)
                ELSE
                  SetMatrixElement(B, i, j, GetMatrixElement(A, i, j) / Pivot)
            ELSE IF j <> m
                   THEN SetMatrixElement(B, i, j, -GetMatrixElement(A, i, j) / Pivot)
                   ELSE SetMatrixElement(B, i, j, 1 / Pivot);
      DestroyMatrix(A);
      CopyMatrix(B, A);
      DestroyMatrix(B);
    END; { Transform }

  BEGIN { InverseMatrix }
    NoExch := 0;
    m := MatrixRows(A);
    n := MatrixColumns(A);
    IF m <> n
      THEN
        BEGIN
          CH := WriteErrorMessage(' Matrix error: inversion of non-quadratic matrix');
          MatrixError := true;
          EXIT;
        END;
    FOR i := 1 TO m DO
      BEGIN
        p := i;
        FOR j := Succ(i) TO n DO
          IF Abs(GetMatrixElement(A, j, i)) > Abs(p)
            THEN p := j;
        IF p <> i
          THEN
            BEGIN
              INC(NoExch);
              Exch[NoExch, 1] := i;
              Exch[NoExch, 2] := p;
              ExchangeRows(A, i, p);
            END;
        Transform(i);
        IF MatrixError THEN EXIT;
      END;
    FOR i := NoExch DOWNTO 1 DO
      ExchangeColumns(A, Exch[i, 2], Exch[i, 1]);
  END; { InverseMatrix }
\end{lstlisting}

Example:
\begin{gather}
   \begin{pmatrix}
      1.00 & 2.00 & 0.00 & -1.00 \\
     -1.00 & 4.00 & 3.00 & -0.50 \\
      2.00 & 2.00 & 1.00 & -3.00 \\
      0.00 & 0.00 & 3.00 & -4.00
   \end{pmatrix}^{-1} =
   \begin{pmatrix}
     -1.95 & 0.19 &  1.57 & -0.71 \\
      0.76 & 0.05 & -0.36 &  0.07 \\
     -1.90 & 0.38 &  1.14 & -0.43 \\
     -1.43 & 0.29 &  0.86 & -0.57
   \end{pmatrix}
\end{gather}

\subsection{Matrix sums and differences}

Matrices, if they have the same size, are added by adding their elements \(\AbsVec{c}_{ij} = \AbsVec{a}_{ij} + \AbsVec{b}_{ij} \):

\begin{lstlisting}[caption=Sum of two matrices]
  PROCEDURE MatrixAdd(CONST A, B: MatrixTyp; VAR Res: MatrixTyp);
  { Elementweise Addition zweier Matrizen. }

  VAR
    i, j, Rows, Columns: WORD;

  BEGIN
    Rows := MatrixRows(A);
    Columns := MatrixColumns(A);
    IF ((Rows <> MatrixRows(B)) OR (Columns <> MatrixColumns(B)))
      THEN
        BEGIN
          CH := WriteErrorMessage(
            ' Matrix error: addition of matrices not of the same size');
          MatrixError := true;
          EXIT;
        END;
    CreateMatrix(Res, Rows, Columns, 0);
    FOR i := 1 TO Rows DO
      FOR j := 1 TO Columns DO
        SetMatrixElement(Res, i, j, GetMatrixElement(A, i, j) + GetMatrixElement(B, i, j));
  END;
\end{lstlisting}

A matrix is multiplied with a scalar by multiplying all elements with the scalar:

\begin{lstlisting}[caption=]
  PROCEDURE SkalarMultiplikation(VAR A: MatrixTyp; x: float);
  { Elementweise Multiplikation einer Matrix mit einem Skalar }

  VAR
    i, j: WORD;

  BEGIN
    FOR i := 1 TO MatrixRows(A) DO
      FOR j := 1 TO MatrixColumns(A) DO
        SetMatrixElement(A, i, j, GetMatrixElement(A, i, j) * x);
  END;
\end{lstlisting}

\subsection{Matrix inner and \Name{Hadamard-Schur} product}

The inner product of a matrix is defined by the inner products of all rows of the first matrix with all columns of the second. Hence the number of columns of the first and the number of rows of the second matrix need to be identical (\skalar{k}): \(\arr{A}_{n\times p} \arr{B}_{p\times q} = \arr{C}_{n\times q}, \AbsVec{c}_{ij} = \AbsVec{a}_{i\cdot} \AbsVec{b}_{\cdot j} = \AbsVec{a}_{i1}\AbsVec{b}_{1j} + \AbsVec{a}_{i2}\AbsVec{b}_{2j}\ldots \AbsVec{a}_{ip}\AbsVec{b}_{pj} = \sum_{k}{\AbsVec{a}_{ik} \AbsVec{b}_{kj}} \). Calculation via the vector dot product has the advantage that the summation is performed by \Name{Neumaier}-process, preventing error accumulation. Note that for square matrices of equal size both \(\arr{AB} \) and \(\arr{BA} \) are defined, but \(\arr{AB} \neq \arr{BA} \).


\begin{lstlisting}[caption=inner product of two matrices]
  PROCEDURE MatrixInnerProduct(CONST A, B: MatrixTyp; VAR C: MatrixTyp);

  VAR
    i, j: WORD;
    Col, Row: VectorTyp;

  BEGIN
    IF MatrixColumns(A) <> MatrixRows(B)
      THEN
        BEGIN
          CH := WriteErrorMessage(' Matrix error: multiplication of A.Columns <> B.Rows');
          MatrixError := true;
          EXIT;
        END;
    CreateMatrix(C, MatrixRows(A), MatrixColumns(B), 0.0);
    FOR i := 1 TO MatrixRows(A) DO
      FOR j := 1 TO MatrixColumns(B) DO
      BEGIN
        GetRow(A, i, Row);
        GetColumn(B, j, Col);
        SetMatrixElement(C, i, j, VectorInnerProduct(Row, Col));
        DestroyVector(Row);
        DestroyVector(Col);
      END;
  END;
\end{lstlisting}

Much rarer used than the inner product of two matrices is the \Name{Hadamard-Schur}- (element-wise) product:

\begin{lstlisting}[caption=Hadamard-Schur product of two matrices]
  PROCEDURE HadamardSchurProduct(CONST A, B: MatrixTyp; VAR C: MatrixTyp);

  VAR
    i, j, n, p: WORD;

  BEGIN
    n := MatrixRows(A);
    IF (n <> MatrixRows(B))
      THEN
        BEGIN
          CH := WriteErrorMessage(' Hadamard-Schur multiplication: A.Rows <> B.Rows');
          MatrixError := true;
          EXIT;
        END;
    p := MatrixColumns(A);
    IF (p <> MatrixColumns(B))
      THEN
        BEGIN
          CH := WriteErrorMessage( 'Hadamard-Schur multiplication: A.Columns <> B.Columns');
          MatrixError := true;
          EXIT;
        END;
    CreateMatrix(C, n, p, 0.0);
    FOR i := 1 TO n DO
      FOR j := 1 TO p DO
        SetMatrixElement(C, i, j, GetMatrixElement(A, i, j) * GetMatrixElement(B, i, j));
  END;
\end{lstlisting}

\subsection{Matrix division}

\begin{lstlisting}[caption=division of two matrices]
  PROCEDURE MatrixDivision(CONST A, B: MatrixTyp; VAR C: MatrixTyp);

  VAR
    Rows, Columns, i, j, k: WORD;
    M, N: MatrixTyp;

  BEGIN
    Rows := MatrixRows(A);
    Columns := MatrixColumns(A);
    IF (Rows <> Columns) OR (Columns <> MatrixRows(B))
      THEN
        BEGIN
          CH := WriteErrorMessage(
            ' Matrix division: A.Columns <> B.Rows or A not quadratic');
          MatrixError := TRUE;
          EXIT;
        END;
    CopyMatrix(A, M);
    CopyMatrix(B, N);
    IF MatrixError THEN EXIT;
    FOR j := 1 TO Rows DO
      BEGIN
        IF GetMatrixElement(M, j, j) = 0
          THEN
            FOR k := j TO Rows DO
              IF GetMatrixElement(M, k, j) <> 0
                THEN
                  BEGIN
                    ExchangeRows(M, j, k);
                    ExchangeRows(N, j, k);
                  END
                ELSE IF k = Rows
                       THEN
                         BEGIN
                           CH := WriteErrorMessage(' Matrix division: no solution');
                           MatrixError := TRUE;
                           EXIT;
                         END;
        FOR i := Succ(j) TO Rows DO
          SetMatrixElement(M, i, j, GetMatrixElement(M, i, j) / GetMatrixElement(M, j, j));
        FOR i := Succ(j) TO Rows DO
          BEGIN
            FOR k := Succ(j) TO Rows DO
              SetMatrixElement(M, i, k, GetMatrixElement(M, i, k) -
                GetMatrixElement(M, j, k) * GetMatrixElement(M, i, j));
            FOR k := 1 TO MatrixColumns(N) DO
              SetMatrixElement(N, i, k, GetMatrixElement(N, i, k) -
                GetMatrixElement(N, j, k) * GetMatrixElement(M, i, j));
          END;
      END;
    FOR i := Rows DOWNTO 1 DO
      FOR k := 1 TO MatrixColumns(N) DO
        BEGIN
          FOR j := Succ(i) TO Columns DO
            SetMatrixElement(N, i, k, GetMatrixElement(N, i, k) -
              GetMatrixElement(N, j, k) * GetMatrixElement(M, i, j));
          SetMatrixElement(N, i, k, GetMatrixElement(N, i, k) /
            GetMatrixElement(M, i, i));
        END;
    CopyMatrix(N, C);
    DestroyMatrix(M);
    DestroyMatrix(N);
  END;
\end{lstlisting}

\begin{lstlisting}[caption=]
  PROCEDURE CenterData(VAR A: MatrixTyp);

  VAR
    Data: VectorTyp;
    j, Columns: WORD;

  BEGIN
    Columns := MatrixColumns(A);
    FOR j := 1 TO Columns DO
      BEGIN
        GetColumn(A, j, Data);
        Centre(Data);
        SetColumn(A, Data, j);
        DestroyVector(Data);
      END;
  END;
\end{lstlisting}


\subsection{Symmetric and anti-symmetric matrices}

The following routine splits a matrix into a symmetric and an anti-symmetric:

\begin{lstlisting}[caption=split matrix in symmetric and anti-symmetic]
  PROCEDURE AntiSym(CONST A: MatrixTyp; VAR Symmetric, Antisymmetric: MatrixTyp);

  VAR
    Dimen, i, j: WORD;

  BEGIN
    Dimen := MatrixRows(A);
    IF Dimen <> MatrixColumns(A)
      THEN
        BEGIN
          CH := WriteErrorMessage('Antisymmetrical of an unsymmetric Matrix');
          MatrixError := true;
          EXIT;
        END;
    FOR i := 1 TO Dimen DO
      FOR j := 1 TO Dimen DO
        BEGIN
          SetMatrixElement(AntiSymmetric, i, j, 0.5 *
            (GetMatrixElement(A, i, j) + GetMatrixElement(A, j, i)));
          SetMatrixElement(Symmetric, i, j, GetMatrixElement(A, i, j) -
            GetMatrixElement(Antisymmetric, i, j));
        END;
  END;
\end{lstlisting}

\subsection{Matrix exponentiation}

The matrix exponential is defined for square matrices \( \arr{X} \in \mathbb{R}_{n\times n} \) or \( \mathbb{C}_{n\times n} \) by a \Name{Taylor}-series:
\begin{equation}
  \mathrm{e}^\arr{X} = \sum_{k=0}^\infty{\frac{\arr{X}^k}{k!}} = \arr{I} + \arr{X} + \frac{\arr{X}^2}{2} + \ldots
\end{equation}
, which always converges.

The matrix exponential shares a number of properties with the exponential on real numbers:
\begin{itemize}
  \item{\( \mathrm{e}^\mathbf{0} = \arr{I} \) }
  \item{\( \mathrm{e}^{a\arr{X}} \mathrm{e}^{b\arr{X}} = \mathrm{e}^{(a+b)\arr{X}} \forall a, b \in \mathbb{C}\) }
  \item{\( \mathrm{e}^\arr{X} \mathrm{e}^{-\arr{X}} = \mathrm{e}^{(1-1)\arr{X}} = \mathrm{e}^\mathbf{0} = \arr{I} \)}
  \item{\( (\mathrm{e}^\arr{X})^{-1} = \mathrm{e}^{-\arr{X}}\) }
  \item{\( \mathrm{e}^\arr{X+Y} = \mathrm{e}^\arr{X} \mathrm{e}^\arr{Y} \) for commuting matrices (\arr{XY} = \arr{YX}). }
  \item{\( \mathrm{e}^{\arr{X}^T} = (\mathrm{e}^\arr{X})^T \)}
  \item{\( \det(\mathrm{e}^\arr{X}) = \mathrm{e}^{\trace(\arr{X})} \) }
  \item{\( \mathrm{e}^{\diag(x_1, x_2, \ldots x_n)} = \diag(\mathrm{e}^{x_1}, \mathrm{e}^{x_2}, \ldots \mathrm{e}^{x_n}) \)}
  \item{\( \mathrm{e}^\arr{X} \) is always invertible. }
\end{itemize}

One applications of the matrix exponential is solving systems of ordinary differential equations, for example starting value problems:
\begin{equation}
  \frac{d}{dt} y(t) = \arr{X}y(t),\quad y(t_0) = y_0
\end{equation}
for square matrix \arr{X} is given by
\begin{equation}
   y(t) = \mathrm{e}^{(t-t_0) \arr{X}} y_0
\end{equation}

For algorithms for matrix exponentials see \parencite{Mol-03,Li-11, Boc-89}.

\section{Calculations with vectors and matrices}

\subsection{Dyadic vector product}

The dyadic vector product multiplies two vectors, resulting in a matrix:
\begin{equation}
  \arr{C}_{n\times p} = \AbsVec{a}_n \otimes \AbsVec{b}_p\quad \AbsVec{c}_{i,j} = \AbsVec{a}_i \times \AbsVec{b}_j
\end{equation}

\begin{lstlisting}[caption=]
  PROCEDURE DyadicVectorProduct(CONST A, B: VectorTyp; VAR C: MatrixTyp);

  VAR
    Row, Column: WORD;

  BEGIN
    CreateMatrix(C, A^.Length, B^.Length, 0.0);
    FOR Row := 1 TO A^.Length DO
      FOR Column := 1 TO B^.Length DO
        SetMatrixElement(C, Row, Column, GetVectorElement(A, Row) *
          GetVectorElement(B, Column));
  END;
\end{lstlisting}

\subsection{Product of a matrix and a vector}

\begin{equation}
  \AbsVec{C}_n = \arr{A}_{n\times p} \star \AbsVec{b}_p\hspace{10mm} \AbsVec{c}_i = \sum_{j=1}^p{\AbsVec{a}_{ij} \times \AbsVec{b}_j}
\end{equation}

\begin{lstlisting}[caption=multiply matrix and vector]
  PROCEDURE MultMatrixVector(CONST Mat: MatrixTyp; CONST Vek: VectorTyp;
    VAR Result: VectorTyp);

  VAR
    Row, Column: WORD;
    Sum: float;

  BEGIN
    IF NOT (MatrixColumns(Mat) = VectorLength(Vek))
      THEN
        BEGIN
          CH := WriteErrorMessage(' Matrix and vector have different number of rows');
          MatrixError := true;
          EXIT;
        END;
    CreateVector(Result, MatrixRows(Mat), 0.0);
    FOR Row := 1 TO MatrixRows(Mat) DO
      BEGIN
        Sum := 0;
        FOR Column := 1 TO MatrixColumns(Mat) DO
          Sum := Sum + GetMatrixElement(Mat, Row, Column) + GetVectorElement(Vek, Column);
        SetVectorElement(Result, Row, Sum);
      END;
  END;
\end{lstlisting}

\subsection{Change a vector to a matrix with one row}

\begin{lstlisting}[caption=change vector to one-dimensional matrix]
  PROCEDURE CangeVectorToMatrix(CONST Vek: VectorTyp; VAR Mat: MatrixTyp);

  VAR
    j: WORD;

  BEGIN
    CreateMatrix(Mat, VectorLength(Vek), 1, 0.0);
    FOR j := 1 TO VectorLength(Vek) DO
      SetMatrixElement(Mat, j, 1, GetVectorElement(Vek, j));
  END;
\end{lstlisting}

\section{Sort rows of a matrix by value of a column}

It is often necessary to sort all rows of a matrix so that a particular column is sorted. We use basically the same routine as for sorting vectors (see \ref{text:sort} on page \pageref{text:sort}.
\begin{lstlisting}[caption=sort matrix]
  PROCEDURE ShellSortMatrix(VAR t: MatrixTyp; Column: WORD);

  LABEL
    10;

  VAR
    i, j, k, l, m, nn, NaNs, n, LdN: INTEGER;
    s: float;
    tmp1, tmp2: VectorTyp;

  BEGIN
    NaNs := 0;
    s := -MaxRealNumber;
    n := MatrixRows(t);
    FOR i := 1 TO n DO
      BEGIN
        IF IsNaN(GetMatrixElement(t, i, Column))    // check forR NaN data
          THEN INC(NaNs)
          ELSE IF (GetMatrixElement(t, i, Column)) > s
                 THEN
                   s := GetMatrixElement(t, i, Column); // and find largest element of data vector
      END;
    s := 10 * s;
    IF (NaNs > 0)
      THEN
        FOR i := 1 TO n DO
          IF IsNaN(GetMatrixElement(t, i, Column))
            THEN SetMatrixElement(t, i, Column, s);
    // replace all NaN WITH very large number so they Move TO END OF vector
    LdN := Trunc(Ln(n) / Const_ln2);
    m := n;
    FOR nn := 1 TO LdN DO
      BEGIN
        m := m DIV 2;
        k := n - m;
        FOR j := 1 TO k DO
          BEGIN
            i := j;
  10:       l := i + m;
            IF (GetMatrixElement(t, l, Column) < GetMatrixElement(t, i, Column))
              THEN
                BEGIN
                  GetRow(t, i, tmp1);
                  GetRow(t, l, tmp2);
                  SetRow(t, tmp2, i);
                  SetRow(t, tmp1, l);
                  DestroyVector(tmp1);
                  DestroyVector(tmp2);
                  i := i - m;
                  IF i >= 1 THEN GOTO 10;
                END;
          END;
      END;
    IF (NaNs > 0)
      THEN
        FOR i := Succ(n - NaNs) TO n DO  // change the top NaNs elements back TO NaN
          SetMatrixElement(t, i, Column, NaN);
  END;

  END. { unit Matrix }
\end{lstlisting}
